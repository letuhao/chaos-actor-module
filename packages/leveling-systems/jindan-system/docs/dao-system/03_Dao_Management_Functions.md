# 03 ‚Äî Dao Management Functions (C√°c H√†m Qu·∫£n L√Ω ƒê·∫°o)

**Generated:** 2025-01-27  
**Based on:** Map-based approach for flexible Dao management

## T·ªïng quan

C√°c h√†m qu·∫£n l√Ω ƒê·∫°o cho ph√©p th√™m, x√≥a, chuy·ªÉn ƒë·ªïi v√† qu·∫£n l√Ω tr·∫°ng th√°i c·ªßa c√°c lo·∫°i ƒê·∫°o m·ªôt c√°ch linh ho·∫°t.

## üöÄ Kh·ªüi T·∫°o H·ªá Th·ªëng

### **InitializeDaoSystem - Kh·ªüi T·∫°o H·ªá Th·ªëng ƒê·∫°o**

```go
// Initialize Dao System (ÂàùÂßãÂåñÈÅìÁ≥ªÁªü) - Kh·ªüi t·∫°o h·ªá th·ªëng ƒê·∫°o
func InitializeDaoSystem() DaoSystem {
    return DaoSystem{
        DaoPaths: make(map[string]DaoPath),
        PrimaryDaoType: "",
        DaoComprehension: DaoComprehension{},
        DaoTechniques: make(map[string][]DaoTechnique),
        DaoCompatibility: DaoCompatibility{
            CompatibilityMatrix: make(map[string]map[string]float64),
            ResonanceEffects: make(map[string]float64),
            SuppressionEffects: make(map[string]float64),
        },
    }
}
```

## ‚ûï Th√™m & X√≥a ƒê·∫°o

### **AddDaoPath - Th√™m Con ƒê∆∞·ªùng ƒê·∫°o**

```go
// Add Dao Path (Ê∑ªÂä†ÈÅìÂæÑ) - Th√™m con ƒë∆∞·ªùng ƒê·∫°o
func (ds *DaoSystem) AddDaoPath(daoType string, daoPath DaoPath) {
    daoPath.DaoType = daoType
    daoPath.IsActive = true
    daoPath.UnlockedAt = time.Now().Unix()
    
    ds.DaoPaths[daoType] = daoPath
    
    // Set as primary if it's the first one (Â¶ÇÊûúÊòØÁ¨¨‰∏Ä‰∏™ÂàôËÆæ‰∏∫‰∏ªÈÅì) - N·∫øu l√† c√°i ƒë·∫ßu ti√™n th√¨ ƒë·∫∑t l√†m ch√≠nh
    if ds.PrimaryDaoType == "" {
        ds.PrimaryDaoType = daoType
        daoPath.IsPrimary = true
        ds.DaoPaths[daoType] = daoPath
    }
}
```

### **RemoveDaoPath - X√≥a Con ƒê∆∞·ªùng ƒê·∫°o**

```go
// Remove Dao Path (ÁßªÈô§ÈÅìÂæÑ) - X√≥a con ƒë∆∞·ªùng ƒê·∫°o
func (ds *DaoSystem) RemoveDaoPath(daoType string) {
    delete(ds.DaoPaths, daoType)
    
    // If removing primary Dao, set a new primary (Â¶ÇÊûúÁßªÈô§‰∏ªÈÅìÂàôËÆæÁΩÆÊñ∞ÁöÑ‰∏ªÈÅì) - N·∫øu x√≥a ƒê·∫°o ch√≠nh th√¨ ƒë·∫∑t ƒê·∫°o ch√≠nh m·ªõi
    if ds.PrimaryDaoType == daoType {
        ds.PrimaryDaoType = ""
        for daoType, dao := range ds.DaoPaths {
            if dao.IsActive {
                ds.PrimaryDaoType = daoType
                dao.IsPrimary = true
                ds.DaoPaths[daoType] = dao
                break
            }
        }
    }
}
```

## üéØ Qu·∫£n L√Ω ƒê·∫°o Ch√≠nh

### **SetPrimaryDao - ƒê·∫∑t ƒê·∫°o Ch√≠nh**

```go
// Set Primary Dao (ËÆæÁΩÆ‰∏ªÈÅì) - ƒê·∫∑t ƒê·∫°o ch√≠nh
func (ds *DaoSystem) SetPrimaryDao(daoType string) bool {
    if dao, exists := ds.DaoPaths[daoType]; exists && dao.IsActive {
        // Remove primary flag from current primary (ÁßªÈô§ÂΩìÂâç‰∏ªÈÅìÁöÑ‰∏ªÈÅìÊ†áÂøó) - X√≥a c·ªù ch√≠nh kh·ªèi ƒê·∫°o ch√≠nh hi·ªán t·∫°i
        if ds.PrimaryDaoType != "" {
            currentPrimary := ds.DaoPaths[ds.PrimaryDaoType]
            currentPrimary.IsPrimary = false
            ds.DaoPaths[ds.PrimaryDaoType] = currentPrimary
        }
        
        // Set new primary (ËÆæÁΩÆÊñ∞‰∏ªÈÅì) - ƒê·∫∑t ƒê·∫°o ch√≠nh m·ªõi
        ds.PrimaryDaoType = daoType
        dao.IsPrimary = true
        ds.DaoPaths[daoType] = dao
        return true
    }
    return false
}
```

## üîÑ Qu·∫£n L√Ω Tr·∫°ng Th√°i

### **ToggleDaoActive - Chuy·ªÉn ƒê·ªïi Tr·∫°ng Th√°i Ho·∫°t ƒê·ªông**

```go
// Toggle Dao Active Status (ÂàáÊç¢ÈÅìÊøÄÊ¥ªÁä∂ÊÄÅ) - Chuy·ªÉn ƒë·ªïi tr·∫°ng th√°i ho·∫°t ƒë·ªông c·ªßa ƒê·∫°o
func (ds *DaoSystem) ToggleDaoActive(daoType string) bool {
    if dao, exists := ds.DaoPaths[daoType]; exists {
        dao.IsActive = !dao.IsActive
        ds.DaoPaths[daoType] = dao
        
        // If deactivating primary Dao, set a new primary (Â¶ÇÊûúÂÅúÁî®‰∏ªÈÅìÂàôËÆæÁΩÆÊñ∞ÁöÑ‰∏ªÈÅì) - N·∫øu t·∫Øt ƒê·∫°o ch√≠nh th√¨ ƒë·∫∑t ƒê·∫°o ch√≠nh m·ªõi
        if !dao.IsActive && ds.PrimaryDaoType == daoType {
            ds.PrimaryDaoType = ""
            for daoType, dao := range ds.DaoPaths {
                if dao.IsActive {
                    ds.PrimaryDaoType = daoType
                    dao.IsPrimary = true
                    ds.DaoPaths[daoType] = dao
                    break
                }
            }
        }
        return true
    }
    return false
}
```

## üìä Truy V·∫•n Th√¥ng Tin

### **GetActiveDaos - L·∫•y C√°c ƒê·∫°o ƒêang Ho·∫°t ƒê·ªông**

```go
// Get Active Daos (Ëé∑ÂèñÊøÄÊ¥ªÁöÑÈÅì) - L·∫•y c√°c ƒê·∫°o ƒëang ho·∫°t ƒë·ªông
func (ds *DaoSystem) GetActiveDaos() []DaoPath {
    var activeDaos []DaoPath
    for _, dao := range ds.DaoPaths {
        if dao.IsActive {
            activeDaos = append(activeDaos, dao)
        }
    }
    return activeDaos
}
```

### **GetDaoByType - L·∫•y ƒê·∫°o Theo Lo·∫°i**

```go
// Get Dao by Type (Ê†πÊçÆÁ±ªÂûãËé∑ÂèñÈÅì) - L·∫•y ƒê·∫°o theo lo·∫°i
func (ds *DaoSystem) GetDaoByType(daoType string) (DaoPath, bool) {
    dao, exists := ds.DaoPaths[daoType]
    return dao, exists
}
```

## üßÆ T√≠nh To√°n Stats

### **CalculateDaoStats - T√≠nh To√°n Stats ƒê·∫°o**

```go
// Calculate Dao stats (ËÆ°ÁÆóÈÅìÂ±ûÊÄß) - T√≠nh to√°n c√°c stats c·ªßa ƒê·∫°o
func CalculateDaoStats(daoSystem DaoSystem) map[string]float64 {
    stats := make(map[string]float64)
    
    // Get primary Dao (Ëé∑Âèñ‰∏ªÈÅì) - L·∫•y ƒê·∫°o ch√≠nh
    primaryDao, exists := daoSystem.DaoPaths[daoSystem.PrimaryDaoType]
    if !exists {
        return stats // Return empty if no primary Dao (Â¶ÇÊûúÊ≤°Êúâ‰∏ªÈÅìÂàôËøîÂõûÁ©∫) - N·∫øu kh√¥ng c√≥ ƒê·∫°o ch√≠nh th√¨ tr·∫£ v·ªÅ r·ªóng
    }
    
    // Core Dao stats (Ê†∏ÂøÉÈÅìÂ±ûÊÄß) - Stats c·ªët l√µi ƒê·∫°o
    stats["dao_level"] = float64(primaryDao.DaoLevel)
    stats["dao_experience"] = primaryDao.DaoExperience
    stats["dao_mastery"] = primaryDao.DaoMastery
    stats["dao_insight"] = primaryDao.DaoInsight
    stats["dao_wisdom"] = primaryDao.DaoWisdom
    
    // Advanced Dao stats (È´òÁ∫ßÈÅìÂ±ûÊÄß) - Stats n√¢ng cao ƒê·∫°o
    stats["dao_harmony"] = primaryDao.DaoHarmony
    stats["dao_transcendence"] = primaryDao.DaoTranscendence
    
    // Calculate total stats across all active Daos (ËÆ°ÁÆóÊâÄÊúâÊøÄÊ¥ªÈÅìÁöÑÊÄªÂ±ûÊÄß) - T√≠nh to√°n t·ªïng stats t·ª´ t·∫•t c·∫£ ƒê·∫°o ƒëang ho·∫°t ƒë·ªông
    totalLevel := 0.0
    totalExperience := 0.0
    totalMastery := 0.0
    activeDaoCount := 0
    
    for _, dao := range daoSystem.DaoPaths {
        if dao.IsActive {
            totalLevel += float64(dao.DaoLevel)
            totalExperience += dao.DaoExperience
            totalMastery += dao.DaoMastery
            activeDaoCount++
        }
    }
    
    // Average stats across active Daos (ÊøÄÊ¥ªÈÅìÁöÑÂπ≥ÂùáÂ±ûÊÄß) - Stats trung b√¨nh c·ªßa c√°c ƒê·∫°o ƒëang ho·∫°t ƒë·ªông
    if activeDaoCount > 0 {
        stats["total_dao_level"] = totalLevel
        stats["total_dao_experience"] = totalExperience
        stats["total_dao_mastery"] = totalMastery
        stats["active_dao_count"] = float64(activeDaoCount)
        stats["average_dao_level"] = totalLevel / float64(activeDaoCount)
    }
    
    // Calculate compatibility and resonance (ËÆ°ÁÆóÂÖºÂÆπÊÄßÂíåÂÖ±ÊåØ) - T√≠nh to√°n t∆∞∆°ng th√≠ch v√† c·ªông h∆∞·ªüng
    stats["dao_compatibility"] = calculateDaoCompatibility(daoSystem.DaoCompatibility)
    stats["dao_resonance"] = calculateDaoResonance(daoSystem.DaoCompatibility)
    stats["dao_suppression"] = calculateDaoSuppression(daoSystem.DaoCompatibility)
    
    // Calculate technique stats (ËÆ°ÁÆóÈÅìÊúØÂ±ûÊÄß) - T√≠nh to√°n stats k·ªπ thu·∫≠t ƒê·∫°o
    techniqueStats := calculateDaoTechniqueStats(daoSystem.DaoTechniques)
    for key, value := range techniqueStats {
        stats[key] = value
    }
    
    return stats
}
```

## üîß H√†m Tr·ª£ Gi√∫p

### **calculateDaoCompatibility - T√≠nh T∆∞∆°ng Th√≠ch ƒê·∫°o**

```go
// Helper functions (ËæÖÂä©ÂáΩÊï∞) - C√°c h√†m tr·ª£ gi√∫p
func calculateDaoCompatibility(compatibility DaoCompatibility) float64 {
    // Calculate overall compatibility (ËÆ°ÁÆóÊÄª‰ΩìÂÖºÂÆπÊÄß) - T√≠nh to√°n t∆∞∆°ng th√≠ch t·ªïng th·ªÉ
    totalCompatibility := 0.0
    count := 0
    
    for _, innerMap := range compatibility.CompatibilityMatrix {
        for _, value := range innerMap {
            totalCompatibility += value
            count++
        }
    }
    
    if count > 0 {
        return totalCompatibility / float64(count)
    }
    return 0.0
}
```

### **calculateDaoResonance - T√≠nh C·ªông H∆∞·ªüng ƒê·∫°o**

```go
func calculateDaoResonance(compatibility DaoCompatibility) float64 {
    // Calculate overall resonance (ËÆ°ÁÆóÊÄª‰ΩìÂÖ±ÊåØ) - T√≠nh to√°n c·ªông h∆∞·ªüng t·ªïng th·ªÉ
    totalResonance := 0.0
    count := 0
    
    for _, value := range compatibility.ResonanceEffects {
        totalResonance += value
        count++
    }
    
    if count > 0 {
        return totalResonance / float64(count)
    }
    return 0.0
}
```

### **calculateDaoSuppression - T√≠nh √Åp Ch·∫ø ƒê·∫°o**

```go
func calculateDaoSuppression(compatibility DaoCompatibility) float64 {
    // Calculate overall suppression (ËÆ°ÁÆóÊÄª‰ΩìÂéãÂà∂) - T√≠nh to√°n √°p ch·∫ø t·ªïng th·ªÉ
    totalSuppression := 0.0
    count := 0
    
    for _, value := range compatibility.SuppressionEffects {
        totalSuppression += value
        count++
    }
    
    if count > 0 {
        return totalSuppression / float64(count)
    }
    return 0.0
}
```

### **calculateDaoTechniqueStats - T√≠nh Stats K·ªπ Thu·∫≠t ƒê·∫°o**

```go
func calculateDaoTechniqueStats(techniques map[string][]DaoTechnique) map[string]float64 {
    stats := make(map[string]float64)
    
    totalPower := 0.0
    totalCost := 0.0
    totalCooldown := 0.0
    totalRange := 0.0
    totalAccuracy := 0.0
    totalTechniques := 0
    
    for _, techniqueList := range techniques {
        for _, technique := range techniqueList {
            totalPower += technique.TechniquePower
            totalCost += technique.TechniqueCost
            totalCooldown += technique.TechniqueCooldown
            totalRange += technique.TechniqueRange
            totalAccuracy += technique.TechniqueAccuracy
            totalTechniques++
        }
    }
    
    if totalTechniques > 0 {
        stats["dao_technique_power"] = totalPower / float64(totalTechniques)
        stats["dao_technique_cost"] = totalCost / float64(totalTechniques)
        stats["dao_technique_cooldown"] = totalCooldown / float64(totalTechniques)
        stats["dao_technique_range"] = totalRange / float64(totalTechniques)
        stats["dao_technique_accuracy"] = totalAccuracy / float64(totalTechniques)
    }
    
    return stats
}
```

## üí° ƒê·∫∑c ƒêi·ªÉm N·ªïi B·∫≠t

### **Map-Based Management:**
- **Flexible**: Qu·∫£n l√Ω nhi·ªÅu ƒê·∫°o c√πng l√∫c
- **Scalable**: D·ªÖ d√†ng th√™m lo·∫°i ƒê·∫°o m·ªõi
- **Efficient**: Truy c·∫≠p O(1) cho m·ªçi thao t√°c

### **Automatic Primary Management:**
- **Auto-assign**: T·ª± ƒë·ªông g√°n ƒê·∫°o ch√≠nh khi th√™m ƒë·∫ßu ti√™n
- **Auto-switch**: T·ª± ƒë·ªông chuy·ªÉn ƒê·∫°o ch√≠nh khi x√≥a/t·∫Øt
- **Consistency**: ƒê·∫£m b·∫£o lu√¥n c√≥ ƒê·∫°o ch√≠nh h·ª£p l·ªá

### **Status Tracking:**
- **Active/Inactive**: Theo d√µi tr·∫°ng th√°i ho·∫°t ƒë·ªông
- **Unlock Time**: Ghi nh·∫≠n th·ªùi ƒëi·ªÉm m·ªü kh√≥a
- **Primary Flag**: Qu·∫£n l√Ω c·ªù ƒê·∫°o ch√≠nh
