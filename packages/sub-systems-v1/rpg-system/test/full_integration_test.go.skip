package test

import (
	"context"
	"testing"
	"time"

	"rpg-stats/internal/integration"
	"rpg-stats/internal/model"
)

func TestFullIntegration_RPGStatsToCoreActor(t *testing.T) {
	// Create mock adapter
	adapter := integration.NewMockMongoAdapter()
	defer adapter.Close()

	// Create integration
	integration := integration.NewCoreActorIntegration(adapter)
	ctx := context.Background()

	// Test 1: Create a new character
	t.Run("Create New Character", func(t *testing.T) {
		// Create initial character data
		progress := &model.PlayerProgress{
			ActorID: "test_character",
			Level:   1,
			XP:      0,
			Allocations: map[model.StatKey]int{
				model.STR: 15,
				model.INT: 12,
				model.WIL: 10,
				model.AGI: 14,
				model.SPD: 13,
				model.END: 16,
				model.PER: 8,
				model.LUK: 11,
			},
			LastUpdated: time.Now().Unix(),
		}

		err := adapter.SavePlayerProgress(ctx, progress)
		if err != nil {
			t.Fatalf("Failed to create character: %v", err)
		}

		// Build Core Actor contribution
		contribution, err := integration.BuildCoreActorContribution(ctx, "test_character")
		if err != nil {
			t.Fatalf("Failed to build contribution: %v", err)
		}

		// Verify primary stats
		if contribution.Primary.HPMax <= 0 {
			t.Errorf("Expected positive HPMax, got %d", contribution.Primary.HPMax)
		}

		if contribution.Primary.Attack <= 0 {
			t.Errorf("Expected positive Attack, got %d", contribution.Primary.Attack)
		}

		if contribution.Primary.Defense <= 0 {
			t.Errorf("Expected positive Defense, got %d", contribution.Primary.Defense)
		}

		if contribution.Primary.Speed <= 0 {
			t.Errorf("Expected positive Speed, got %d", contribution.Primary.Speed)
		}

		// Verify flat modifiers
		if contribution.Flat["HPMax"] <= 0 {
			t.Errorf("Expected positive HPMax flat modifier, got %f", contribution.Flat["HPMax"])
		}

		if contribution.Flat["ATK"] <= 0 {
			t.Errorf("Expected positive ATK flat modifier, got %f", contribution.Flat["ATK"])
		}

		// Verify tags are generated
		if len(contribution.Tags) == 0 {
			t.Errorf("Expected some tags to be generated")
		}

		t.Logf("Character created successfully")
		t.Logf("Primary Stats: HP=%d, Attack=%d, Defense=%d, Speed=%d",
			contribution.Primary.HPMax, contribution.Primary.Attack,
			contribution.Primary.Defense, contribution.Primary.Speed)
		t.Logf("Tags: %v", contribution.Tags)
	})

	// Test 2: Level up and allocate stats
	t.Run("Level Up and Allocate Stats", func(t *testing.T) {
		updates := &integration.PlayerStatsUpdates{
			XPGranted:     1000,
			LevelIncrease: 2,
			StatAllocations: map[model.StatKey]int{
				model.STR: 3,
				model.INT: 2,
				model.END: 2,
			},
		}

		contribution, err := integration.UpdatePlayerStats(ctx, "test_character", updates)
		if err != nil {
			t.Fatalf("Failed to update stats: %v", err)
		}

		// Verify stats increased
		if contribution.Primary.HPMax < 200 { // Should be higher after level up
			t.Errorf("Expected higher HPMax after level up, got %d", contribution.Primary.HPMax)
		}

		if contribution.Primary.Attack < 30 { // Should be higher after STR allocation
			t.Errorf("Expected higher Attack after STR allocation, got %d", contribution.Primary.Attack)
		}

		t.Logf("Level up successful")
		t.Logf("New Stats: HP=%d, Attack=%d, Defense=%d",
			contribution.Primary.HPMax, contribution.Primary.Attack,
			contribution.Primary.Defense)
	})

	// Test 3: Equip items
	t.Run("Equip Items", func(t *testing.T) {
		// Create equipment
		sword := model.StatModifier{
			Key:   model.STR,
			Op:    model.ADD_FLAT,
			Value: 5.0,
			Source: model.ModifierSourceRef{
				Kind:  "item",
				ID:    "iron_sword",
				Label: "Iron Sword",
			},
			Priority: 1,
		}

		armor := model.StatModifier{
			Key:   model.END,
			Op:    model.ADD_FLAT,
			Value: 3.0,
			Source: model.ModifierSourceRef{
				Kind:  "item",
				ID:    "leather_armor",
				Label: "Leather Armor",
			},
			Priority: 1,
		}

		updates := &integration.PlayerStatsUpdates{
			ItemsEquipped: map[string]model.StatModifier{
				"weapon": sword,
				"armor":  armor,
			},
		}

		contribution, err := integration.UpdatePlayerStats(ctx, "test_character", updates)
		if err != nil {
			t.Fatalf("Failed to equip items: %v", err)
		}

		// Verify equipment effects
		if contribution.Flat["ATK"] < 40 { // Should be higher with sword
			t.Errorf("Expected higher ATK with sword, got %f", contribution.Flat["ATK"])
		}

		if contribution.Flat["DEF"] < 20 { // Should be higher with armor
			t.Errorf("Expected higher DEF with armor, got %f", contribution.Flat["DEF"])
		}

		t.Logf("Equipment equipped successfully")
		t.Logf("Equipment Stats: ATK=%.2f, DEF=%.2f",
			contribution.Flat["ATK"], contribution.Flat["DEF"])
	})

	// Test 4: Apply buffs
	t.Run("Apply Buffs", func(t *testing.T) {
		strengthBuff := model.StatModifier{
			Key:   model.STR,
			Op:    model.MULTIPLY,
			Value: 1.2, // 20% increase
			Source: model.ModifierSourceRef{
				Kind:  "buff",
				ID:    "strength_potion",
				Label: "Strength Potion",
			},
			Priority: 2,
			Conditions: &model.ModifierConditions{
				DurationMs: 300000, // 5 minutes
			},
		}

		updates := &integration.PlayerStatsUpdates{
			EffectsAdded: []model.StatModifier{strengthBuff},
		}

		contribution, err := integration.UpdatePlayerStats(ctx, "test_character", updates)
		if err != nil {
			t.Fatalf("Failed to apply buff: %v", err)
		}

		// Verify buff effects
		if contribution.Mult["CritChance"] <= 1.0 { // Should have some multiplicative effect
			t.Errorf("Expected multiplicative effect, got %f", contribution.Mult["CritChance"])
		}

		t.Logf("Buff applied successfully")
		t.Logf("Multiplicative modifiers: CritChance=%.2f", contribution.Mult["CritChance"])
	})

	// Test 5: Grant title
	t.Run("Grant Title", func(t *testing.T) {
		title := model.StatModifier{
			Key:   model.PER,
			Op:    model.ADD_FLAT,
			Value: 2.0,
			Source: model.ModifierSourceRef{
				Kind:  "title",
				ID:    "noble_warrior",
				Label: "Noble Warrior",
			},
			Priority: 1,
		}

		updates := &integration.PlayerStatsUpdates{
			TitlesGranted: map[string]model.StatModifier{
				"noble_warrior": title,
			},
		}

		contribution, err := integration.UpdatePlayerStats(ctx, "test_character", updates)
		if err != nil {
			t.Fatalf("Failed to grant title: %v", err)
		}

		// Verify title effects
		if contribution.Flat["amplifiers.social"] <= 1.0 {
			t.Errorf("Expected social amplifier > 1.0, got %f", contribution.Flat["amplifiers.social"])
		}

		// Check for title-related tags
		hasNobleTag := false
		for _, tag := range contribution.Tags {
			if tag == "charismatic" || tag == "very_charismatic" {
				hasNobleTag = true
				break
			}
		}

		if !hasNobleTag {
			t.Errorf("Expected charismatic tag from high personality")
		}

		t.Logf("Title granted successfully")
		t.Logf("Social amplifier: %.2f", contribution.Flat["amplifiers.social"])
		t.Logf("Tags: %v", contribution.Tags)
	})

	// Test 6: Get stat breakdown
	t.Run("Get Stat Breakdown", func(t *testing.T) {
		breakdown, err := integration.GetStatBreakdown(ctx, "test_character", model.STR)
		if err != nil {
			t.Fatalf("Failed to get breakdown: %v", err)
		}

		if breakdown == nil {
			t.Errorf("Expected breakdown to be present")
		} else {
			if breakdown.Base <= 0 {
				t.Errorf("Expected positive base value, got %f", breakdown.Base)
			}

			if breakdown.AdditiveFlat <= 0 {
				t.Errorf("Expected positive additive flat value, got %f", breakdown.AdditiveFlat)
			}

			t.Logf("Stat breakdown retrieved successfully")
			t.Logf("STR Breakdown: Base=%.2f, AdditiveFlat=%.2f, Multiplicative=%.2f",
				breakdown.Base, breakdown.AdditiveFlat, breakdown.Multiplicative)
		}
	})

	// Test 7: Complex scenario - Multiple effects
	t.Run("Complex Scenario", func(t *testing.T) {
		// Add multiple effects
		effects := []model.StatModifier{
			{
				Key:   model.ATK,
				Op:    model.ADD_PCT,
				Value: 15.0, // 15% increase
				Source: model.ModifierSourceRef{
					Kind:  "buff",
					ID:    "battle_rage",
					Label: "Battle Rage",
				},
				Priority: 2,
				Conditions: &model.ModifierConditions{
					DurationMs: 600000, // 10 minutes
				},
			},
			{
				Key:   model.DEF,
				Op:    model.ADD_PCT,
				Value: 10.0, // 10% increase
				Source: model.ModifierSourceRef{
					Kind:  "buff",
					ID:    "defensive_stance",
					Label: "Defensive Stance",
				},
				Priority: 2,
				Conditions: &model.ModifierConditions{
					DurationMs: 300000, // 5 minutes
				},
			},
		}

		updates := &integration.PlayerStatsUpdates{
			EffectsAdded: effects,
		}

		contribution, err := integration.UpdatePlayerStats(ctx, "test_character", updates)
		if err != nil {
			t.Fatalf("Failed to apply multiple effects: %v", err)
		}

		// Verify complex interactions
		if contribution.Flat["ATK"] < 50 { // Should be significantly higher
			t.Errorf("Expected higher ATK with multiple effects, got %f", contribution.Flat["ATK"])
		}

		if contribution.Flat["DEF"] < 30 { // Should be higher with defensive stance
			t.Errorf("Expected higher DEF with defensive stance, got %f", contribution.Flat["DEF"])
		}

		t.Logf("Complex scenario completed successfully")
		t.Logf("Final Stats: ATK=%.2f, DEF=%.2f, HP=%d",
			contribution.Flat["ATK"], contribution.Flat["DEF"], contribution.Primary.HPMax)
	})
}

func TestFullIntegration_ErrorHandling(t *testing.T) {
	adapter := integration.NewMockMongoAdapter()
	defer adapter.Close()

	integration := integration.NewCoreActorIntegration(adapter)
	ctx := context.Background()

	// Test error handling for non-existent player
	t.Run("Non-existent Player", func(t *testing.T) {
		_, err := integration.BuildCoreActorContribution(ctx, "nonexistent")
		if err == nil {
			t.Errorf("Expected error for non-existent player")
		}
	})

	// Test error handling for invalid updates
	t.Run("Invalid Updates", func(t *testing.T) {
		// Create a player first
		progress := &model.PlayerProgress{
			ActorID: "test_player",
			Level:   1,
			XP:      0,
			Allocations: map[model.StatKey]int{
				model.STR: 10,
			},
			LastUpdated: time.Now().Unix(),
		}
		adapter.SavePlayerProgress(ctx, progress)

		// Try to update with invalid data
		updates := &integration.PlayerStatsUpdates{
			XPGranted: -100, // Invalid negative XP
		}

		_, err := integration.UpdatePlayerStats(ctx, "test_player", updates)
		// This should not error in our current implementation, but in a real system
		// you might want to validate input
		if err != nil {
			t.Logf("Update validation error (expected): %v", err)
		}
	})
}
